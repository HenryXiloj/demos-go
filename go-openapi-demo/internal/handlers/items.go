// Package handlers contains the HTTP handler implementations for the API.
package handlers

import (
	"encoding/json"
	"net/http"
	"sync"
	"sync/atomic"

	"go-openapi-demo/api"
)

// ItemsService is a simple in-memory service implementing the server interface.
// It is concurrency-safe via a RWMutex.
type ItemsService struct {
	mu        sync.RWMutex       // guards access to the map below
	items     map[int64]api.Item // in-memory storage of items by ID
	currentID int64              // auto-incrementing ID counter
}

// NewItemsService seeds a couple of sample items and returns a ready service.
func NewItemsService() *ItemsService {
	s := &ItemsService{
		items:     map[int64]api.Item{},
		currentID: 2, // start beyond the seeded IDs below
	}
	s.items[1] = api.Item{Id: 1, Name: "Item 1"}
	s.items[2] = api.Item{Id: 2, Name: "Item 2"}
	return s
}

// GetItems returns all items.
// Method signature matches the non-strict interface generated by oapi-codegen.
func (s *ItemsService) GetItems(w http.ResponseWriter, r *http.Request) {
	s.mu.RLock()
	out := make([]api.Item, 0, len(s.items))
	for _, it := range s.items {
		out = append(out, it)
	}
	s.mu.RUnlock()

	// Write JSON response
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	_ = json.NewEncoder(w).Encode(out)
}

// GetItemById returns one item if it exists; 404 otherwise.
func (s *ItemsService) GetItemById(w http.ResponseWriter, r *http.Request, id int64) {
	s.mu.RLock()
	it, ok := s.items[id]
	s.mu.RUnlock()
	if !ok {
		http.Error(w, "not found", http.StatusNotFound)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	_ = json.NewEncoder(w).Encode(it)
}

// CreateItem creates a new item from JSON body and returns it with 201 Created.
func (s *ItemsService) CreateItem(w http.ResponseWriter, r *http.Request) {
	var req api.ItemCreate
	// Decode request JSON body into ItemCreate
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "bad request", http.StatusBadRequest)
		return
	}

	// Generate a new unique ID atomically
	id := atomic.AddInt64(&s.currentID, 1)
	item := api.Item{Id: id, Name: req.Name}

	// Store the new item
	s.mu.Lock()
	s.items[id] = item
	s.mu.Unlock()

	// Respond with the created resource
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusCreated)
	_ = json.NewEncoder(w).Encode(item)
}

// UpdateItem replaces an item's fields; returns 404 if the item doesn't exist.
func (s *ItemsService) UpdateItem(w http.ResponseWriter, r *http.Request, id int64) {
	var req api.ItemUpdate
	// Decode request JSON body into ItemUpdate
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "bad request", http.StatusBadRequest)
		return
	}

	s.mu.Lock()
	defer s.mu.Unlock()
	if _, ok := s.items[id]; !ok {
		http.Error(w, "not found", http.StatusNotFound)
		return
	}

	// Update and return the item
	s.items[id] = api.Item{Id: id, Name: req.Name}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	_ = json.NewEncoder(w).Encode(s.items[id])
}

// DeleteItem removes an item by ID; returns 404 if not found.
// Note: your OpenAPI spec currently only defines 204 for DELETE.
// If you want to return 404, add it to the spec for full alignment.
func (s *ItemsService) DeleteItem(w http.ResponseWriter, r *http.Request, id int64) {
	s.mu.Lock()
	_, ok := s.items[id]
	if ok {
		delete(s.items, id)
	}
	s.mu.Unlock()

	if !ok {
		http.Error(w, "not found", http.StatusNotFound)
		return
	}

	w.WriteHeader(http.StatusNoContent)
}

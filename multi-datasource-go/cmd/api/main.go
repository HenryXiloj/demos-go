package main

import (
	"context"
	"database/sql"
	"fmt"
	"log"
	"time"

	"multi-datasource-go/internal/config"
	"multi-datasource-go/internal/db"
	"multi-datasource-go/internal/http"
	"multi-datasource-go/internal/repo"

	"github.com/gin-gonic/gin"
	"github.com/jackc/pgx/v5/pgxpool"
)

func main() {
	cfg, err := config.Load()
	if err != nil {
		log.Fatalf("failed to load config: %v", err)
	}

	// Open pools
	var (
		mysqlDB  = mustMySQL(cfg)
		pgPool   = mustPG(cfg)
		oracleDB = mustOracle(cfg)
	)

	// ✅ call this as a normal statement (not in the var block)
	createTables(mysqlDB, pgPool, oracleDB)

	h := &http.Handlers{
		Users:     repo.NewMySQLUserRepo(mysqlDB),
		Companies: repo.NewPGCompanyRepo(pgPool),
		Brands:    repo.NewOracleBrandRepo(oracleDB),
		Timeout:   time.Duration(cfg.App.RequestTimeoutSec) * time.Second,
	}

	r := gin.New()
	r.Use(gin.Recovery())
	h.Register(r)

	addr := ":" + itoa(cfg.App.HTTPPort)
	log.Printf("listening on %s", addr)
	if err := r.Run(addr); err != nil {
		log.Fatal(err)
	}
}

func itoa(i int) string { return fmt.Sprintf("%d", i) }

func mustMySQL(cfg *config.Config) *sql.DB {
	if !cfg.MySQL.Enabled {
		return nil
	}
	dbx, err := db.OpenMySQL(
		cfg.MySQL.DSN,
		cfg.MySQL.MaxOpenConns,
		cfg.MySQL.MaxIdleConns,
		cfg.MySQL.ConnMaxLifetimeMin,
		cfg.MySQL.ConnMaxIdleMin,
	)
	if err != nil {
		log.Fatalf("mysql: %v", err)
	}
	return dbx
}

func mustPG(cfg *config.Config) *pgxpool.Pool {
	if !cfg.Postgres.Enabled {
		return nil
	}
	// OpenPGPool signature: (ctx, dsn, maxConns, minConns, lifeMin, idleMin)
	pool, err := db.OpenPGPool(
		context.Background(),
		cfg.Postgres.DSN,
		cfg.Postgres.MaxOpenConns,       // maxConns
		cfg.Postgres.MaxIdleConns,       // use idle as a reasonable minConns
		cfg.Postgres.ConnMaxLifetimeMin, // lifeMin
		cfg.Postgres.ConnMaxIdleMin,     // idleMin
	)
	if err != nil {
		log.Fatalf("postgres: %v", err)
	}
	return pool
}

func mustOracle(cfg *config.Config) *sql.DB {
	if !cfg.Oracle.Enabled {
		return nil
	}
	dbx, err := db.OpenOracle(
		cfg.Oracle.DSN,
		cfg.Oracle.MaxOpenConns,
		cfg.Oracle.MaxIdleConns,
		cfg.Oracle.ConnMaxLifetimeMin,
		cfg.Oracle.ConnMaxIdleMin,
	)
	if err != nil {
		log.Fatalf("oracle: %v", err)
	}
	return dbx
}

func createTables(mysqlDB *sql.DB, pgPool *pgxpool.Pool, oracleDB *sql.DB) {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	// --- MySQL ---
	if mysqlDB != nil {
		_, err := mysqlDB.ExecContext(ctx, `
			CREATE DATABASE IF NOT EXISTS test_db;
		`)
		if err != nil {
			log.Printf("mysql create db: %v", err)
		}
		_, err = mysqlDB.ExecContext(ctx, `
			CREATE TABLE IF NOT EXISTS users (
				id BIGINT AUTO_INCREMENT PRIMARY KEY,
				name VARCHAR(100) NOT NULL,
				last_name VARCHAR(100) NOT NULL
			);
		`)
		if err != nil {
			log.Printf("mysql create table: %v", err)
		}
		log.Println("✅ ensured MySQL table: users")
	}

	// --- PostgreSQL ---
	if pgPool != nil {
		_, err := pgPool.Exec(ctx, `
			CREATE TABLE IF NOT EXISTS companies (
				id BIGSERIAL PRIMARY KEY,
				name TEXT NOT NULL
			);
		`)
		if err != nil {
			log.Printf("postgres create table: %v", err)
		} else {
			log.Println("✅ ensured Postgres table: companies")
		}
	}

	// --- Oracle ---
	if oracleDB != nil {
		_, err := oracleDB.ExecContext(ctx, `
			BEGIN
				EXECUTE IMMEDIATE 'CREATE TABLE brands (
					id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
					name VARCHAR2(100) NOT NULL
				)';
			EXCEPTION
				WHEN OTHERS THEN
					IF SQLCODE != -955 THEN RAISE; END IF; -- ORA-00955 = already exists
			END;
		`)
		if err != nil {
			log.Printf("oracle create table: %v", err)
		} else {
			log.Println("✅ ensured Oracle table: brands")
		}
	}
}
